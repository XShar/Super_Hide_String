Всем привет.

Часто бывают ситуации, когда нужно скрыть используемую в программе строку от реверсера.

Давайте рассмотрем, где может-быть видна ваша строка, при исследовании кода:

1)В hex-редакторе, компилятор помещает вашу строку в .data - секцию исполняемого файла.
2)Если анализировать динамически код, т.е. после запуска, то после расшифровки ваша строка окажется в ОЗУ (в зависимости от реализации либо на стеке, либо в куче).

Теперь давайте посмотрим способы скрытия данных:

1)От статического анализа, тут всё просто, нужно шифровать строку, либо до компиляции (что неудобно), либо во время компиляции, в этом проекте это реализовано, т.е. строка будет шифроваться методм XOR на этапе сборки проекта.

2)Как-же защитить данные от динамического анализа, тут без запутывание реверсера необойтись, что сделано в этом проекте:

- Как сказано, что строка будет шифроваться на этапе сборки методом XOR, но этого мало, поэтому во время запуска программы уже зашифрованная строка зашифруется методом XTEA3, за основу была взята библиотека https://github.com/XShar/xtea3_lib

Тем самым после расшифровки XTEA3 у нас в куче будет не оригинальная строка, а его зашифрованный вариант. Далее нам нужно расшифровать уже методом XOR.

Это уже небольшое запутывание кода, но и этого мне показалось мало.)

Генерация ключа, очень важный процесс в шифровании, рассмотрим как будет генерироваться ключ для расшифровки:

1.Для XOR, тут всё просто, это случайное число (Которое мы получим каждый раз разное, после пересборки проекта).

2.А вот для генерации ключа для XTEA3 мы будем использовать значение, который вернет треш-код из этого проекта:https://github.com/XShar/super_gen_trash_c, в треш-код будет подаваться число полученное в первом пункте, т.е. после каждой пересборки у нас будут разные ключи и вообще программа будет немного по разному себя вести.

Что в итоге получили:

Алгоритм такой:

1.Шифрование строки методом XOR на этапе компиляции с рандомным ключем, полученным на этапе компиляции проекта;
2.Получение ключа для расшифровки, запутывая реверсера и последующее шифрование уже зашифрованной строки. 

1)Наша строка небудет видна при статическом анализе кода.
2)Что-бы добраться до строки нужно исследовать код в рантайме. 

Как использовать, пример:

	//ВАРИАНТ1:

	//Создаём класс с зашифрованной строкой
	HIDE_STR(hide_str, "Hide String1");
	//Получаем указатель на расшифрованную строку
	uint8_t *decrypt_string = hide_str.decrypt();
	MessageBoxA(0, (LPCSTR)decrypt_string, (LPCSTR)decrypt_string, MB_OK);
	//Освобождаем память
	hide_str.str_free(decrypt_string);

	//ВАРИАНТ2:
	//Более простой
	MessageBoxA(0, (LPCSTR)PRINT_HIDE_STR("Hide String2"), (LPCSTR)PRINT_HIDE_STR("Hide String2"), MB_OK);
	
Первый вариант отличается от второго, тем-что мы можем потом очистить память расшифрованной строки и в первом варианте мы можем получить указатель на шифрованную строку.

Доступные методы класса:

Получит указатель на расшифрованную строку:
uint8_t *decrypt(void) 

Получит указатель на зашифрованную строку:
uint8_t *crypt(void)

Освободит память класса:
str_free(uint8_t *ptr)

В репозитории есть пример (main.c) и собранный проект.
