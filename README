Всем привет.

Часто бывают ситуации, когда нужно скрыть используемую в программе строку от реверсера.

Давайте рассмотрим, где может быть видна ваша строка, при исследовании кода:

1)В hex-редакторе, компилятор помещает вашу строку в .data - секцию исполняемого файла.
2)Если анализировать динамически код, т.е. после запуска, то после расшифровки ваша строка окажется в ОЗУ (в зависимости от реализации либо на стеке, либо в куче).

Теперь давайте посмотрим способы скрытия данных:

1)От статического анализа, тут всё просто, нужно шифровать строку, либо до компиляции (что неудобно), либо во время компиляции, в этом проекте это реализовано, т.е. строка будет шифроваться методом XOR на этапе сборки проекта.

2)Как же защитить данные от динамического анализа, тут без запутывания реверсера не обойтись, что сделано в этом проекте:

- Как сказано, что строка будет шифроваться на этапе сборки методом XOR, но этого мало, поэтому во время запуска программы уже зашифрованная строка зашифруется методом XTEA3, за основу была взята библиотека https://github.com/XShar/xtea3_lib

Тем самым после расшифровки XTEA3 у нас в куче будет не оригинальная строка, а его зашифрованный вариант. Далее нам нужно расшифровать уже методом XOR.

Это уже небольшое запутывание кода, но и этого мне показалось мало.)

Генерация ключа, очень важный процесс в шифровании, рассмотрим как будет генерироваться ключ для расшифровки:

1. Для XOR, тут всё просто, это случайное число (Которое мы получим каждый раз разное, после пересборки проекта).

2. А вот для генерации ключа для XTEA3 мы будем использовать значение, который вернет треш-код из этого проекта:https://github.com/XShar/super_gen_trash_c, в треш-код будет подаваться число полученное в первом пункте, т.е. после каждой пересборки у нас будут разные ключи и вообще программа будет немного по-разному себя вести.

Алгоритм такой:

1. Шифрование строки методом XOR на этапе компиляции с рандомным ключом, полученным на этапе компиляции проекта;
2. Получение ключа для расшифровки, запутывая реверсера и последующее шифрование/расшифрование уже зашифрованной строки.

Что в итоге получили:

1)Наша строка не будет видна при статическом анализе кода.
2)Чтобы добраться до строки нужно исследовать код в рантайме.

Как использовать, пример:

//ВАРИАНТ1:

//Создаём класс с зашифрованной строкой
HIDE_STR(hide_str, "Hide String1");
//Получаем указатель на расшифрованную строку
uint8_t *decrypt_string = hide_str.decrypt();
MessageBoxA(0, (LPCSTR)decrypt_string, (LPCSTR)decrypt_string, MB_OK);
//Освобождаем память
hide_str.str_free(decrypt_string);

//ВАРИАНТ2:
//Более простой
MessageBoxA(0, (LPCSTR)PRINT_HIDE_STR("Hide String2"), (LPCSTR)PRINT_HIDE_STR("Hide String2"), MB_OK);

Первый вариант отличается от второго тем, что мы можем потом очистить память расшифрованной строки и в первом варианте мы можем получить указатель на шифрованную строку.

Доступные методы класса:

Получит указатель на расшифрованную строку:
uint8_t *decrypt(void)

Получит указатель на зашифрованную строку:
uint8_t *crypt(void)

Освободит память класса:
str_free(uint8_t *ptr)

В репозитории есть пример (main.c) и собранный проект.
